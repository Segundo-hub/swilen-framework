<?php

use Swilen\Security\Exception\JwtDomainException;
use Swilen\Security\Exception\JwtInvalidSignatureException;
use Swilen\Security\Exception\JwtMalformedException;
use Swilen\Security\Exception\JwtTokenExpiredException;
use Swilen\Security\Token\Decoder;
use Swilen\Security\Token\Jwt;
use Swilen\Security\Token\JwtSignedExpression;
use Swilen\Security\Token\Payload;
use Swilen\Security\Token\Util;

uses()->group('Security', 'Token');

define('STATIC_SECRET', 'jwt6350d205f2b27');

dataset('malformed-tokens', [
    'nfsdfiwrtni.ndfgnirtret',
    'nvisdndutgrt.mnigdgii64.34gdffgurtyt.midtert',
    'nvisdfnnert8356',
]);

dataset('valid-tokens', [
    (new Jwt())->sign(['exp' => time() + 20, 'data' => ['userId' => uniqid()]], STATIC_SECRET, 'HS256')->plainTextToken,
    (new Jwt())->sign(['exp' => time() + 40], STATIC_SECRET, 'HS256')->plainTextToken,
    (new Jwt())->sign(['exp' => time() + 30], STATIC_SECRET, 'HS256')->plainTextToken,
]);

it('Instance Jwt created successfuly', function () {
    $jwt = (new Jwt())->sign([
        'iat' => time(),
        'exp' => time() + 720,
    ], STATIC_SECRET, 'HS256');

    expect($jwt)->toBeInstanceOf(JwtSignedExpression::class);
    expect($jwt->payload)->toBeInstanceOf(Payload::class);
    expect($jwt->payload->expires())->toBeInt();
    expect($jwt->payload->iat())->toBeInt();
    expect($jwt->payload->data())->toBeArray();
    expect($jwt->plainTextToken)->toBeString();
    expect($jwt->__toString())->toBeString();
});

it('Created jwt instance with missing secret key', function () {
    (new Jwt())->sign([
        'iat' => time(),
        'exp' => time() + 720,
    ]);
})->throws(JwtDomainException::class, 'Missing secret key.');

it('Created jwt instance with missing algorithm', function () {
    (new Jwt())->sign([
        'iat' => time(),
        'exp' => time() + 720,
    ], STATIC_SECRET);
})->throws(JwtDomainException::class, 'Missing algorithm.');

it('Created jwt instance with not supported algorithm', function () {
    (new Jwt())->sign([
        'iat' => time(),
        'exp' => time() + 720,
    ], STATIC_SECRET, 'unknow-algo');
})->throws(JwtDomainException::class, 'The algorithm "unknow-algo" is not supported.');

it('Add automatically exp in payload when not exists', function () {
    $generated = (new Jwt())->sign([
        'data' => 'example',
    ], 'secret', 'HS512');

    $decode = (new Decoder($generated))->decode();

    expect($decode->payload->expires())->toBeNumeric();
});

it('Create Jwt and verify token generated', function () {
    $payload = [
        'iat' => time(),
        'exp' => time() + 5,
        'data' => [
            'userId' => 34,
            'username' => 'Jhonas',
            'role' => 'admin',
        ],
    ];

    $jwt = (new Jwt())->sign($payload, STATIC_SECRET, 'HS256');

    expect($jwt->plainTextToken)->toBeString();

    $result = (new Jwt())->verify($jwt->plainTextToken, STATIC_SECRET, 'HS256');

    expect($result)->toBeInstanceOf(Payload::class);
    expect($result->data())->toBe($payload['data']);
});

it('Jwt validations tokens', function ($token) {
    $result = (new Jwt())->verify($token, STATIC_SECRET, 'HS256');

    expect($result)->toBeInstanceOf(Payload::class);
    expect($result->data())->toBeArray();
    expect($result->expires())->toBeInt();
})->with('valid-tokens');

it('Jwt Error time expired', function () {
    $payload = [
        'iat' => time(),
        'exp' => time() - 5,
    ];

    $jwt = (new Jwt())->sign($payload, STATIC_SECRET, 'HS256');

    expect($jwt->plainTextToken)->toBeString();
    expect($jwt->payload->data())->toBeEmpty()->toBeArray();

    (new Jwt())->verify($jwt->plainTextToken, STATIC_SECRET, 'HS256');
})->throws(JwtTokenExpiredException::class);

it('Jwt Error token malformed', function ($token) {
    (new Jwt())->verify($token, STATIC_SECRET, 'HS256');
})->with('malformed-tokens')->throws(JwtMalformedException::class);

it('Throw error when token is altered', function () {
    $generated = (new Jwt())->sign([
        'data' => 'other',
        'exp' => time() + 40,
    ], 'secret', 'HS512');

    $random = alterJwt($generated);

    $jwt = (new Jwt())->verify($random->plainTextToken, 'secret', 'HS512');
})->throws(JwtInvalidSignatureException::class);

it('Decoder token match with token generated by Jwt', function () {
    $generated = (new Jwt())->sign([
        'data' => 'other',
        'exp' => time() + 40,
    ], 'secret', 'HS512');

    expect((new Decoder($generated->plainTextToken))->token())->toBe($generated->plainTextToken);
});

function alterJwt(JwtSignedExpression $expresion)
{
    $decode = (new Decoder($expresion->plainTextToken))->decode();

    $payload = new Payload(array_replace($decode->payload->jsonSerialize(), [
        'data' => [
            'role' => 'superadmin',
        ],
    ]));

    return new JwtSignedExpression(Util::dotted(
        $decode->header->encode(), $payload->encode(), $decode->signature), $payload
    );
}
